/*
 * generated by Xtext
 */
package org.elysium.parser.antlr;

import org.antlr.runtime.CommonToken;
import org.antlr.runtime.Token;
import org.antlr.runtime.TokenSource;
import org.eclipse.xtext.parser.antlr.AbstractSplittingTokenSource;
import org.eclipse.xtext.parser.antlr.ITokenAcceptor;
import org.elysium.parser.antlr.MarkupBodyFinisher.InsertEndPosition;
import org.elysium.parser.antlr.lexer.InternalLilyPondLexer;

public class LilyPondTokenSource extends AbstractSplittingTokenSource {

	protected LilyPondTokenSource(TokenSource delegate) {
		setDelegate(delegate);
	}

	private boolean commandStarted=false;
	private MarkupBodyFinisher currentMarkup=null;

	@Override
	protected boolean shouldSplitToken(Token candidate) {
		checkMarkUpStatus(candidate);
		if(currentMarkup!=null){
			return true;
		}else{
			return false;
		}
	}

	private void checkMarkUpStatus(Token candidate) {
		if(currentMarkup!=null){
			return;
		}
		int tokenType=candidate.getType();
		switch (tokenType){
			case InternalLilyPondLexer.ReverseSolidus:
				commandStarted=true;
				break;
			case InternalLilyPondLexer.Markup:
			case InternalLilyPondLexer.Markuplines:
			case InternalLilyPondLexer.Markuplist:
				if(commandStarted){
					commandStarted=false;
					currentMarkup=new MarkupBodyFinisher();
				}
				break;
			default: commandStarted=false;
		}
	}

	@Override
	protected void doSplitToken(Token splitMe, ITokenAcceptor acceptor) {
		InsertEndPosition positionToInsertEnd = currentMarkup.getInsertMarkupEndPosition(splitMe);
		if(positionToInsertEnd==InsertEndPosition.NOT){
			acceptor.accept(splitMe);
			return;
		}else{
			int offset=((CommonToken) splitMe).getStopIndex()+1;
			CommonToken result = new CommonToken(InternalLilyPondLexer.RULE_ASSIGNMENT_NL);
			result.setText("");
			result.setChannel(Token.DEFAULT_CHANNEL);
			result.setStartIndex(offset);
			result.setStopIndex(offset-1);
			if(positionToInsertEnd==InsertEndPosition.BEFORE){
				acceptor.accept(result);
				acceptor.accept(splitMe);
			}else{
				acceptor.accept(splitMe);
				acceptor.accept(result);
			}
//		System.out.println("I SPLIT HERE");
			currentMarkup=null;
		}
	}
}
